{"mappings":"AACA,gEAAgE;AAEhE,IAAI,cAAc,GAAG,KAAK,AAAC;AAE3B,mCAAmC;AACnC,MAAM,cAAc,qCAAqC,AAAC;AAC1D,MAAM,cAAc,eAAe,AAAC;AACpC,SAAS,aAAa,CAAC,IAAI,EAAE;IACzB,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC,AAAC;IAC1D,MAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,GAAC,CAAC,EAAE,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,cAAc,CAAC,AAAC;IAC3F,OAAO,MAAM,KAAK,IAAI,GAAG,EAAE,GAAG,MAAM,CAAC;CACxC;AAED,wDAAwD;AACxD,mDAAmD;AACnD,IAAI,WAAW,GAAG,CAAC,GAAG,GAAK,GAAG,CAAC,OAAO,cAAc,SAAU,CAAC,EAAE;QAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;KAAE,CAAC,AAAC;AAEjG,sBAAsB;AACtB,SAAS,QAAQ,GAAG;IAChB,MAAM,KAAK,GAAG;QACV,OAAO,EAAE,CAAC;QACV,OAAO,EAAE,CAAC;QACV,IAAI,EAAE,EAAE;QACR,OAAO,EAAE,CAAC,GAAG,GAAK,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,GAAG,GAAG;QACnD,OAAO,EAAE,IAAM;YACX,IAAI,KAAK,CAAC,OAAO,IAAI,KAAK,CAAC,OAAO,EAC9B,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,CAAC;YAEtC,OAAO,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;SACtC;QACD,IAAI,EAAE,IAAM,KAAK,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO;QACzC,OAAO,EAAE,IAAM,KAAK,CAAC,OAAO,IAAI,KAAK,CAAC,OAAO;KAChD,AAAC;IACF,OAAO,KAAK,CAAC;CAChB;AAED,MAAM,QAAQ,GAAG;IACb,QAAQ,EAAE,IAAI,GAAG,EAAE;IACnB,mBAAmB,EAAE,IAAI,GAAG,EAAE;IAC9B,qBAAqB,EAAE,IAAI,GAAG,EAAE;IAChC,aAAa,EAAE,QAAQ,EAAE;IACzB,KAAK,EAAE,EAAE;IACT,YAAY,EAAE,EAAE;IAChB,UAAU,EAAE,KAAK;IACjB,MAAM,EAAE,EAAE;IAEV,QAAQ,EAAE,SAAS,GAAG,GAAG,EAAE;QACvB,MAAM,QAAQ,GAAG,CAAC,EAAE,EAAE,MAAM,GAAK;YAC7B,IAAI,CAAE,CAAA,EAAE,YAAY,QAAQ,CAAA,AAAC,EACzB,MAAM,IAAI,KAAK,CAAC,+BAA+B,GAAG,EAAE,CAAC,CAAC;YAE1D,IAAI,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,EAC7B,MAAM,IAAI,KAAK,CAAC,kCAAkC,GAAG,MAAM,CAAC,CAAC;YAGjE,qDAAqD;YACrD,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;YAElC,uEAAuE;YACvE,MAAM,UAAU,GAAG,aAAa,CAAC,EAAE,CAAC,AAAC;YAErC,aAAa;YACb,QAAQ,CAAC,mBAAmB,CAAC,GAAG,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;YACrD,KAAK,MAAM,MAAM,IAAI,UAAU,CAAE;gBAC7B,IAAI,KAAK,GAAG,QAAQ,CAAC,qBAAqB,CAAC,GAAG,CAAC,MAAM,CAAC,AAAC;gBACvD,IAAI,CAAC,KAAK,EACN,QAAQ,CAAC,qBAAqB,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK,GAAG,EAAE,CAAC,CAAC;gBAE3D,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;aACtB;SACJ,AAAC;QACF,IAAI,SAAS,CAAC,MAAM,IAAI,CAAC,IACd,OAAO,SAAS,CAAC,CAAC,CAAC,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EACvE,6EAA6E;QAC7E,KAAK,MAAM,CAAC,OAAM,EAAE,GAAE,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CACnD,QAAQ,CAAC,GAAE,EAAE,OAAM,CAAC,CAAC;aAGzB,iFAAiF;QACjF,KAAK,MAAM,GAAE,IAAI,GAAG,CAChB,QAAQ,CAAC,GAAE,EAAE,GAAE,CAAC,IAAI,CAAC,CAAC;KAGjC;IAED,GAAG,EAAE,eAAe,eAAe,EAAE;QACjC,0CAA0C;QAC1C,MAAM,SAAS,GAAG,CAAC,IAAI,EAAE,OAAO,EAAE,aAAa,EAAE,SAAS,GAAK;YAC3D,IAAI,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,EACvB,MAAM,IAAI,KAAK,CAAC,uCAAuC,GAAG,aAAa,CAAC,CAAC;YAE7E,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YACxB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;gBACpB,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;gBAClB,iDAAiD;gBACjD,MAAM,SAAS,GAAG,QAAQ,CAAC,qBAAqB,CAAC,GAAG,CAAC,IAAI,CAAC,AAAC;gBAC3D,IAAI,SAAS,EACT,KAAK,MAAM,QAAQ,IAAI,SAAS,CAAE;oBAC9B,MAAM,IAAI,GAAG,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,AAAC;oBAC7C,uCAAuC;oBACvC,SAAS,CAAC,IAAI,CAAC,CAAC;oBAChB,2BAA2B;oBAC3B,SAAS,CAAC,QAAQ,EAAE,OAAO,EAAE,aAAa,EAAE,SAAS,CAAC,CAAC;iBAC1D;aAER;YACD,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SAC9B,AAAC;QACF,8EAA8E;QAC9E,MAAM,2BAA2B,GAAG,CAAC,UAAU,EAAE,SAAS,GAAK;YAC3D,MAAM,OAAO,GAAG,IAAI,GAAG,EAAE,AAAC;YAC1B,MAAM,aAAa,GAAG,IAAI,GAAG,EAAE,AAAC;YAChC,KAAK,MAAM,SAAS,IAAI,UAAU,CAC9B,SAAS,CAAC,SAAS,EAAE,OAAO,EAAE,aAAa,EAAE,SAAS,CAAC,CAAC;SAE/D;QACD,kEAAkE;QAClE,MAAM,YAAY,GAAG,CAAC,IAAI,EAAE,KAAK,EAAE,iBAAiB,GAAK;YACrD,qCAAqC;YACrC,MAAM,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,AAAC;YACtC,iDAAiD;YACjD,MAAM,YAAY,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,EAAE,KAAK,CAAC,AAAC;YACjD,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,YAAY,CAAC;YAC3C,IAAI,YAAY,EAAE;gBACd,IAAI,cAAc,EACd,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE;oBAAC,CAAC,IAAI,CAAC,EAAE,KAAK;iBAAC,CAAC,CAAC;gBAE7C,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;aAChC;YACD,oEAAoE;YACpE,MAAM,SAAS,GAAG,QAAQ,CAAC,qBAAqB,CAAC,GAAG,CAAC,IAAI,CAAC,AAAC;YAC3D,IAAI,SAAS,EACT,SAAS,CAAC,OAAO,CAAC,CAAA,QAAQ,GAAI;gBAC1B,MAAM,IAAI,GAAG,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,AAAC;gBAC7C,IAAI,EAAE,IAAI,CAAC,YAAY,IAAI,CAAC,EACxB,sEAAsE;gBACtE,wDAAwD;gBACxD,iBAAiB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;aAEvC,CAAC,CAAC;SAEV;QAED,4FAA4F;QAC5F,4FAA4F;QAC5F,sDAAsD;QACtD,qDAAqD;QACrD,QAAQ,CAAC,aAAa,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;QAEhD,+FAA+F;QAC/F,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE;YACtB,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC;YAE3B,gEAAgE;YAChE,QAAQ,CAAC,MAAM,GAAG,EAAE,CAAC;YAErB,wFAAwF;YACxF,MAAO,CAAC,QAAQ,CAAC,aAAa,CAAC,OAAO,EAAE,CAAE;gBACtC,MAAM,WAAW,GAAG,QAAQ,CAAC,aAAa,CAAC,OAAO,EAAE,AAAC;gBAErD,wFAAwF;gBACxF,oFAAoF;gBACpF,KAAK,MAAM,GAAE,IAAI,QAAQ,CAAC,QAAQ,CAAC,MAAM,EAAE,CACvC,GAAE,CAAC,YAAY,GAAG,CAAC,CAAC;gBAExB,2BAA2B,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,EAAE,GAAK,EAAE,CAAC,YAAY,EAAE,CAAC,CAAC;gBAEjF,+BAA+B;gBAC/B,QAAQ,CAAC,YAAY,GAAG,EAAE,CAAC;gBAE3B,sFAAsF;gBACtF,iCAAiC;gBACjC,IAAI,cAAc,GAAG,IAAI,GAAG,EAAE,AAAC;gBAC/B,KAAK,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,CACnD,YAAY,CAAC,IAAI,EAAE,KAAK,EAAE,cAAc,CAAC,CAAC;gBAG9C,gFAAgF;gBAChF,MAAO,cAAc,CAAC,IAAI,GAAG,CAAC,CAAE;oBAC5B,iDAAiD;oBACjD,0DAA0D;oBAC1D,kEAAkE;oBAClE,wDAAwD;oBACxD,MAAM,QAAQ,GAAG,EAAE,AAAC;oBACpB,MAAM,OAAO,GAAG,EAAE,AAAC;oBACnB,MAAM,MAAM,GAAG,EAAE,AAAC;oBAClB,KAAK,MAAM,IAAI,IAAI,cAAc,CAAE;wBAC/B,yBAAyB;wBACzB,MAAM,EAAE,GAAG,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,AAAC;wBACvC,2DAA2D;wBAC3D,MAAM,IAAI,GAAG,EAAE,AAAC;wBAChB,MAAM,UAAU,GAAG,QAAQ,CAAC,mBAAmB,CAAC,GAAG,CAAC,IAAI,CAAC,AAAC;wBAC1D,IAAI,cAAc,GAAG,KAAK,AAAC;wBAC3B,MAAM,iBAAiB,GAAG,cAAc,GAAG,EAAE,GAAG,SAAS,AAAC;wBAC1D,KAAK,MAAM,SAAS,IAAI,UAAU,CAAE;4BAChC,IAAI,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,EAChC,cAAc,GAAG,IAAI,CAAC;4BAE1B,MAAM,GAAG,GAAG,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,AAAC;4BACtC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;4BACf,IAAI,cAAc,EACd,iBAAiB,CAAC,SAAS,CAAC,GAAG,GAAG,CAAC;yBAE1C;wBACD,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;wBACtB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;wBAClB,IAAI,cAAc,EAAE;4BAChB,4EAA4E;4BAC5E,+BAA+B;4BAC/B,IAAI,cAAc,EACd,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE;gCAAC,CAAC,IAAI,CAAC,EAAE,iBAAiB;6BAAC,CAAC,CAAC;4BAEzD,6DAA6D;4BAC7D,QAAQ,CAAC,IAAI,CAAC,EAAE,IAAI,IAAI,CAAC,CAAC,CAAC;yBAC9B,MACG,mEAAmE;wBACnE,oEAAoE;wBACpE,wDAAwD;wBACxD,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;qBAE5D;oBAED,iFAAiF;oBACjF,cAAc,CAAC,KAAK,EAAE,CAAC;oBAEvB,qEAAqE;oBACrE,MAAM,cAAc,GAAG,MAAM,OAAO,CAAC,UAAU,CAAC,QAAQ,CAAC,AAAC;oBAC1D,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE;wBACrC,MAAM,aAAa,GAAG,cAAc,CAAC,CAAC,CAAC,AAAC;wBACxC,IAAI,aAAa,CAAC,MAAM,KAAK,WAAW,EACpC,yCAAyC;wBACzC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,aAAa,CAAC,KAAK,EAAE,cAAc,CAAC,CAAC;6BAC3D,IAAI,aAAa,CAAC,MAAM,KAAK,UAAU,EAAE;4BAC5C,aAAa;4BACb,MAAM,OAAO,GAAG;gCAAE,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC;gCAAE,cAAc,EAAE,MAAM,CAAC,CAAC,CAAC;gCACjE,MAAM,EAAE,aAAa,CAAC,MAAM;6BAAC,AAAC;4BAClC,OAAO,CAAC,GAAG,CAAC,yCAAyC,EAAE,OAAO,CAAC,CAAC;4BAChE,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;yBACjC,MACG,OAAO,CAAC,GAAG,CAAC,wBAAwB,EAAE,aAAa,CAAC,CAAC;qBAE5D;iBACJ;gBACD,IAAI,cAAc,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,OAAO,EAAE,EACnD,OAAO,CAAC,GAAG,CAAC,sCAAsC,CAAC,CAAC;aAE3D;YACD,QAAQ,CAAC,UAAU,GAAG,KAAK,CAAC;YAC5B,IAAI,cAAc,EACd,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC;SAErC;KACJ;IAED,YAAY,EAAE,IAAM;QAChB,MAAM,YAAY,0BAA0B,AAAC;QAC7C,MAAM,iBAAiB,0BAA0B,AAAC;QAElD,mBAAmB;QACnB,yFAAyF;QACzF,MAAM,mBAAmB,GAAG,EAAE,AAAC;QAC/B,IAAI,KAAK,GAAG,CAAC,AAAC;QACd;eAAI,QAAQ,CAAC,gBAAgB,CAAC,iBAAiB,CAAC;SAAC,CAAC,OAAO,CAAC,CAAA,GAAG,GAAI;YAC7D,4CAA4C;YAC5C,MAAM,oBAAoB,GAAG,GAAG,CAAC,YAAY,CAAC,eAAe,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,AAAC;YAC1E,KAAK,MAAM,eAAe,IAAI,oBAAoB,CAAE;gBAChD,MAAM,WAAW,GAAG,CAAC,IAAI,GAAK;oBAC1B,IAAI,CAAC,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,EACjC,MAAM,IAAI,KAAK,CAAC,uEAAuE,GAC7E,GAAG,CAAC,SAAS,CAAC,CAAC;oBAE7B,OAAO,IAAI,CAAC;iBACf;gBACD,MAAM,cAAc,GAAG,CAAC,GAAG,GAAK,GAAG,GAAG,wBAAwB,GAAG,GAAG,AAAC;gBACrE,IAAI,MAAM,AAAC;gBACX,IAAI,QAAQ,AAAC;gBACb,IAAI,eAAe,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;oBACrC,uEAAuE;oBACvE,MAAM,KAAK,GAAG,eAAe,CAAC,KAAK,CAAC,SAAS,CAAC,AAAC;oBAC/C,QAAQ,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;oBACjC,MAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,AAAC;oBAC3B,MAAM,GAAG,MAAM,GAAG,QAAQ,GAAG,oBAAoB,GACvC,QAAQ,GAAG,+BAA+B,GAAG,SAAS,GAAG,MAAM,GACrE,wBAAwB,GAAG,SAAS,GAAG,KAAK;iBAEnD,MAAM,IAAI,eAAe,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;oBAC5C,wCAAwC;oBACxC,MAAM,KAAK,GAAG,eAAe,CAAC,KAAK,CAAC,SAAS,CAAC,AAAC;oBAC/C,QAAQ,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;oBACjC,MAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,AAAC;oBAC3B,MAAM,GAAG,YAAY,GAAG,WAAW,CAAC,SAAS,CAAC,GAAG,KAAK,GAAG,cAAc,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC;iBAE3F,MAAM,IAAI,eAAe,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE;oBAC3C,6CAA6C;oBAC7C,MAAM,KAAK,GAAG,eAAe,CAAC,KAAK,CAAC,QAAQ,CAAC,AAAC;oBAC9C,QAAQ,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;oBACjC,MAAM,cAAc,GAAG,KAAK,CAAC,CAAC,CAAC,AAAC;oBAChC,qEAAqE;oBACrE,MAAM,GACF,AAAC,CAAA,QAAQ,KAAK,iBAAiB,GAAG,qCAAqC,GAAG,EAAE,CAAA,GAC5E,UAAU,GAAG,cAAc,GAAG,kBAAkB,GAC1C,MAAM,GAAG,cAAc,GAAG,KAAK,GAAG,cAAc,CAAC,QAAQ,CAAC,GAC9D,SAAS,GACL,oBAAoB,GAAG,cAAc,GAAG,KAAK,GAAG,cAAc,CAAC,QAAQ,CAAC,GAAG,IAAI,GAC9E,CAAA,QAAQ,KAAK,iBAAiB,GAAG,oCAAoC,GAAG,EAAE,CAAA,AAAC,CAAC,CAAC,OAAO;iBAElG,MAAM;oBACH,+BAA+B;oBAC/B,QAAQ,GAAG,eAAe,CAAC;oBAC3B,MAAM,GAAG,kBAAkB,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC;iBAC1D;gBACD,8BAA8B;gBAC9B,MAAM,YAAY,GAAG,SAAS,GAAG,KAAK,EAAE,AAAC;gBACzC,gFAAgF;gBAChF,iFAAiF;gBACjF,iCAAiC;gBACjC,MAAM,KAAK,GAAG,WAAW,GAAG,YAAY,GAAG,GAAG,GAAG,QAAQ,GAAG,MAAM,GAAG,MAAM,GAAG,IAAI,AAAC;gBACnF,IAAI;oBACA,uBAAuB;oBACvB,IAAI,CAAC,KAAK,CAAC,CAAC;oBACZ,mCAAmC;oBACnC,MAAM,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,AAAC;oBAC9B,wBAAwB;oBACxB,mBAAmB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;iBAChC,CAAC,OAAO,CAAC,EAAE;oBACR,OAAO,CAAC,GAAG,CAAC,iBAAiB,EAAE,KAAK,EAAE,WAAW,EAAE,CAAC,CAAC,CAAC;iBACzD;aACJ;SACJ,CAAC,CAAC;QACH,gCAAgC;QAChC,QAAQ,CAAC,QAAQ,IAAI,mBAAmB,CAAC,CAAC;QAE1C,mBAAmB;QACnB,gGAAgG;QAChG,4FAA4F;QAC5F,oFAAoF;QACpF,MAAM,aAAa,GAAG,CAAC,GAAG,GAAK,GAAG,CAAC,IAAI,KAAK,UAAU,IAAI,GAAG,CAAC,IAAI,KAAK,OAAO,GAAG,GAAG,CAAC,OAAO,GAAG,GAAG,CAAC,KAAK,AAAC;QACzG,MAAM,aAAa,GAAG,EAAE,AAAC;QACzB,MAAM,iBAAiB,GAAG,CAAC,SAAS,GAAK;YACrC,MAAM,QAAQ,GAAG,iBAAiB,GAAG,SAAS,AAAC;YAC/C;mBAAI,QAAQ,CAAC,gBAAgB,CAAC,GAAG,GAAG,QAAQ,GAAG,GAAG,CAAC;aAAC,CAAC,OAAO,CAAC,CAAA,GAAG,GAAI;gBAChE,IAAI,GAAG,CAAC,OAAO,CAAC,WAAW,EAAE,KAAK,OAAO,EACrC,MAAM,IAAI,KAAK,CAAC,eAAe,GAAG,QAAQ,GAAG,sCAAsC,GACzE,GAAG,CAAC,SAAS,CAAC,CAAC;gBAE7B,MAAM,eAAe,GAAG,GAAG,CAAC,YAAY,CAAC,QAAQ,CAAC,AAAC;gBACnD,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,eAAe,CAAC,EACnC,MAAM,IAAI,KAAK,CACX,QAAQ,GAAG,0DAA0D,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC;gBAE/F,GAAG,CAAC,gBAAgB,CAAC,SAAS,EAAE,IAAM,QAAQ,CAAC,GAAG,CAAC;wBAAE,CAAC,eAAe,CAAC,EAAE,aAAa,CAAC,GAAG,CAAC;qBAAE,CAAC,CAAC,CAAC;gBAC/F,aAAa,CAAC,eAAe,CAAC,GAAG,aAAa,CAAC,GAAG,CAAC,CAAC;aACvD,CAAC;SACL,AAAC;QACF,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QAC5B,iBAAiB,CAAC,OAAO,CAAC,CAAC;QAC3B,mDAAmD;QACnD,IAAI,cAAc,EACd,OAAO,CAAC,GAAG,CAAC,iBAAiB,EAAE,aAAa,CAAC,CAAC;QAElD,QAAQ,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;KAC/B;CACJ,AAAC","sources":["dublr-ui/dataflow-lib.js"],"sourcesContent":["\n// Note: This library depends upon Lodash -- https://lodash.com/\n\nlet DEBUG_DATAFLOW = false;\n\n// Extract function parameter names\nconst STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nconst ARGUMENT_NAMES = /([^\\s,]+)/g;\nfunction getParamNames(func) {\n    const fnStr = func.toString().replace(STRIP_COMMENTS, '');\n    const result = fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n    return result === null ? [] : result;\n}\n\n// Convert hyphen separated attribute names to camelCase\n// From https://stackoverflow.com/a/6661012/3950982\nvar toCamelCase = (str) => str.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });\n\n// Queue datastructure\nfunction newQueue() {\n    const queue = {\n        headIdx: 0,\n        tailIdx: 0,\n        elts: {},\n        enqueue: (elt) => queue.elts[queue.tailIdx++] = elt,\n        dequeue: () => {\n            if (queue.headIdx == queue.tailIdx) {\n                throw new Error(\"Queue is empty\");\n            }\n            return queue.elts[queue.headIdx++];\n        },\n        size: () => queue.tailIdx - queue.headIdx,\n        isEmpty: () => queue.tailIdx == queue.headIdx\n    };\n    return queue;\n}\n\nconst dataflow = {\n    nameToFn: new Map(),               // name -> function\n    nodeToUpstreamNodes: new Map(),    // name -> list of names\n    nodeToDownstreamNodes: new Map(),  // name -> list of names\n    updateBatches: newQueue(),         // queue of {name: value} objects\n    value: {},                         // name -> value (as Object) -- read this for cached values\n    valueChanged: {},                  // name -> boolean\n    inProgress: false,\n    errors: [],\n    \n    register: function(...fns) {\n        const register = (fn, fnName) => {\n            if (!(fn instanceof Function)) {\n                throw new Error(\"Parameter is not a function: \" + fn);\n            }\n            if (dataflow.nameToFn.has(fnName)) {\n                throw new Error(\"Function is already registered: \" + fnName);\n            }\n            \n            // Index functions by name (these are the node names)\n            dataflow.nameToFn.set(fnName, fn);\n\n            // Extract param names from function (these are the upstream dep names)\n            const paramNames = getParamNames(fn);\n            \n            // Create DAG\n            dataflow.nodeToUpstreamNodes.set(fnName, paramNames);\n            for (const usName of paramNames) {\n                var dsFns = dataflow.nodeToDownstreamNodes.get(usName);\n                if (!dsFns) {\n                    dataflow.nodeToDownstreamNodes.set(usName, dsFns = []);\n                }\n                dsFns.push(fnName);\n            }\n        };\n        if (arguments.length == 1\n                && typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n            // Accept registration in the form of `dataflow.register({fnName: () => val})\n            for (const [fnName, fn] of Object.entries(arguments[0])) {\n                register(fn, fnName);\n            }\n        } else {\n            // Accept registration as a list of named functions: `dataflow.register(a, b, c)`\n            for (const fn of fns) {\n                register(fn, fn.name);\n            }\n        }\n    },\n\n    set: async function(nameToValuesObj) {\n        // Visit a node and its transitive closure\n        const visitNode = (name, visited, visitedInPath, fnVisitor) => {\n            if (visitedInPath.has(name)) {\n                throw new Error(\"Cycle detected, consisting of nodes: \" + visitedInPath);\n            }\n            visitedInPath.add(name);\n            if (!visited.has(name)) {\n                visited.add(name);\n                // Visit downstream functions of node recursively\n                const dsFnNames = dataflow.nodeToDownstreamNodes.get(name);\n                if (dsFnNames) {\n                    for (const dsFnName of dsFnNames) {\n                        const dsFn = dataflow.nameToFn.get(dsFnName);\n                        // Call visitor lambda on function node\n                        fnVisitor(dsFn);\n                        // Recurse to function node\n                        visitNode(dsFnName, visited, visitedInPath, fnVisitor);\n                    }\n                }\n            }\n            visitedInPath.delete(name);\n        };\n        // Visit the downstream transisive closure starting from a list of param names\n        const visitReachableFnsFromParams = (paramNames, fnVisitor) => {\n            const visited = new Set();\n            const visitedInPath = new Set();\n            for (const paramName of paramNames) {\n                visitNode(paramName, visited, visitedInPath, fnVisitor);\n            }\n        }\n        // Update the value of a node, and propagate any change downstream\n        const setNodeValue = (name, value, dirtyNodeNamesOut) => {\n            // Only propagate value if it changed\n            const oldValue = dataflow.value[name];\n            // Uses Lodash -- https://lodash.com/docs#isEqual\n            const valueChanged = !_.isEqual(oldValue, value);\n            dataflow.valueChanged[name] = valueChanged;\n            if (valueChanged) {\n                if (DEBUG_DATAFLOW) {\n                    console.log(\"Setting:\", {[name]: value});\n                }\n                dataflow.value[name] = value;\n            }\n            // Add names of direct downstream nodes to the dirtyNodeNamesOut set\n            const dsFnNames = dataflow.nodeToDownstreamNodes.get(name);\n            if (dsFnNames) {\n                dsFnNames.forEach(dsFnName => {\n                    const dsFn = dataflow.nameToFn.get(dsFnName);\n                    if (--dsFn.numDirtyDeps == 0) {\n                        // The current node is the last dependency of the downstream node that\n                        // needs updating, so the downstream node can be updated\n                        dirtyNodeNamesOut.add(dsFnName);\n                    }\n                });\n            }\n        }\n\n        // Changes need to be scheduled, so that code running inside a node's function can call set.\n        // If set is called while a node's function is running, the update will be only be run after\n        // the current complete dataflow update has completed.\n        // This allows for dynamic dataflow, in batched mode.\n        dataflow.updateBatches.enqueue(nameToValuesObj);\n        \n        // Don't process the updateBatches queue if there is already a Promise processing these batches\n        if (!dataflow.inProgress) {\n            dataflow.inProgress = true;\n\n            // Clear the `errors` field at the beginning of batch processing\n            dataflow.errors = [];\n\n            // Continue running batches until there are none left (batches can be dynamically added)\n            while (!dataflow.updateBatches.isEmpty()) {\n                const updateBatch = dataflow.updateBatches.dequeue();\n                \n                // Find the downstream transitive closure from all nodes reachable from the nodes listed\n                // in updateBatch, and count the number of dirty upstream dependencies for each node\n                for (const fn of dataflow.nameToFn.values()) {\n                    fn.numDirtyDeps = 0;\n                }\n                visitReachableFnsFromParams(Object.keys(updateBatch), (fn) => fn.numDirtyDeps++);\n\n                // Mark all values as unchanged\n                dataflow.valueChanged = {};\n\n                // Set the values of the nodes named in updateBatch, creating the initial dirty set of\n                // direct downstream dependencies\n                var dirtyNodeNames = new Set();\n                for (const [name, value] of Object.entries(updateBatch)) {\n                    setNodeValue(name, value, dirtyNodeNames);\n                }\n\n                // Propagate changes until all nodes in the transitive closure have been updated\n                while (dirtyNodeNames.size > 0) {\n                    // Schedule and await all pending function calls.\n                    // For all (async) functions corresponding to dirty nodes,\n                    // fetch the cached value for all upstream deps (i.e. all params),\n                    // call the function, and collect the resulting promise.\n                    const promises = [];\n                    const fnNames = [];\n                    const fnArgs = [];\n                    for (const name of dirtyNodeNames) {\n                        // Get the named function\n                        const fn = dataflow.nameToFn.get(name);\n                        // Get cached upstream node values for each parameter of fn\n                        const args = [];\n                        const paramNames = dataflow.nodeToUpstreamNodes.get(name);\n                        let someArgChanged = false;\n                        const paramNamesAndArgs = DEBUG_DATAFLOW ? {} : undefined;\n                        for (const paramName of paramNames) {\n                            if (dataflow.valueChanged[paramName]) {\n                                someArgChanged = true;\n                            }\n                            const arg = dataflow.value[paramName];\n                            args.push(arg);\n                            if (DEBUG_DATAFLOW) {\n                                paramNamesAndArgs[paramName] = arg;\n                            }\n                        }\n                        fnNames.push(fn.name);\n                        fnArgs.push(args);\n                        if (someArgChanged) {\n                            // Only call fn if at least one param value changed, to avoid repeating work\n                            // (i.e. implement memoization)\n                            if (DEBUG_DATAFLOW) {\n                                console.log(\"Calling:\", {[name]: paramNamesAndArgs});\n                            }\n                            // Call fn with these params, returning the resulting promise\n                            promises.push(fn(...args));\n                        } else {\n                            // Otherwise reuse cached val (we still need to propagate unchanged\n                            // value down dataflow graph, so that fn.numDirtyDeps gets correctly\n                            // decremented all the way down the transitive closure).\n                            promises.push(Promise.resolve(dataflow.value[name]));\n                        }\n                    }\n\n                    // Clear the dirty nodes list to prep for the next stage of wavefront propagation\n                    dirtyNodeNames.clear();\n                    \n                    // Wait for all promises to be resolved, yielding maximal concurrency\n                    const promiseResults = await Promise.allSettled(promises);\n                    for (var i = 0; i < fnNames.length; i++) {\n                        const promiseResult = promiseResults[i];\n                        if (promiseResult.status === \"fulfilled\") {\n                            // Cache successful function call results\n                            setNodeValue(fnNames[i], promiseResult.value, dirtyNodeNames);\n                        } else if (promiseResult.status === \"rejected\") {\n                            // Log errors\n                            const errInfo = { functionName: fnNames[i], functionParams: fnArgs[i],\n                                reason: promiseResult.reason};\n                            console.log(\"Error executing dataflow node function:\", errInfo);\n                            dataflow.errors.push(errInfo);\n                        } else {\n                            console.log(\"Unknown promise result\", promiseResult);\n                        }\n                    }\n                }\n                if (DEBUG_DATAFLOW && !dataflow.updateBatches.isEmpty()) {\n                    console.log(\"Starting next dynamic dataflow batch\");\n                }\n            }\n            dataflow.inProgress = false;\n            if (DEBUG_DATAFLOW) {\n                console.log(\"Dataflow ended\");\n            }\n        }\n    },\n    \n    connectToDOM: () => {\n        const validJSIdent = /^[A-Z_$][0-9A-Z_$]*$/i;\n        const validHTMLAttrName = /^[A-Z_-][0-9A-Z_-]*$/i;\n                \n        // dataflow to DOM:\n        // Register dataflow functions to push values back out to the DOM when there are changes.\n        const functionsToRegister = [];\n        let idIdx = 0;\n        [...document.querySelectorAll(\"[from-dataflow]\")].forEach(elt => {\n            // Allow multiple comma-separated directives\n            const dataflowAttrValParts = elt.getAttribute(\"from-dataflow\").split(\",\");\n            for (const dataflowAttrVal of dataflowAttrValParts) {\n                const getNodeName = (part) => {\n                    if (!part || !validJSIdent.test(part)) {\n                        throw new Error(\"from-dataflow attribute does not specify a valid dataflow node name: \"\n                                + elt.outerHTML);\n                    }\n                    return part;\n                }\n                const definedOrBlank = (val) => val + \" === undefined ? '' : \" + val;\n                let setter;\n                let nodeName;\n                if (dataflowAttrVal.includes(\":class:\")) {\n                    // CSS class name is specified after \".\", and dataflow value is boolean\n                    const parts = dataflowAttrVal.split(\":class:\");\n                    nodeName = getNodeName(parts[0]);\n                    const className = parts[1];\n                    setter = \"if (\" + nodeName + \" !== undefined && \" \n                            + nodeName + \" !== elt.classList.contains('\" + className + \"')) \" +\n                        \"elt.classList.toggle('\" + className + \"');\"\n                        \n                } else if (dataflowAttrVal.includes(\":style:\")) {\n                    // CSS style name is specified after \"#\"\n                    const parts = dataflowAttrVal.split(\":style:\");\n                    nodeName = getNodeName(parts[0]);\n                    const styleName = parts[1];\n                    setter = \"elt.style.\" + toCamelCase(styleName) + \" = \" + definedOrBlank(nodeName) + \";\";\n                    \n                } else if (dataflowAttrVal.includes(\":attr:\")) {\n                    // HTML attribute name is specified after \":\"\n                    const parts = dataflowAttrVal.split(\":attr:\");\n                    nodeName = getNodeName(parts[0]);\n                    const targetAttrName = parts[1];\n                    // Use property setter if it is available, otherwise use setAttribute\n                    setter =\n                        (nodeName === \"allowBuying_out\" ? \"console.log('CURR: ', elt.checked);\" : \"\") + // TODO\n                        \"if (elt.\" + targetAttrName + \" !== undefined) \"\n                            + \"elt.\" + targetAttrName + \" = \" + definedOrBlank(nodeName)\n                        + \"; else \"\n                            + \"elt.setAttribute('\" + targetAttrName + \"', \" + definedOrBlank(nodeName) + \");\"\n                            + (nodeName === \"allowBuying_out\" ? \"console.log('NEW: ', elt.checked);\" : \"\"); // TODO\n                    \n                } else {\n                    // Default to setting innerHTML\n                    nodeName = dataflowAttrVal;\n                    setter = \"elt.innerHTML = \" + definedOrBlank(nodeName);\n                }\n                // Create unique function name\n                const functionName = \"setDOM_\" + idIdx++;\n                // eval is the only way to create functions with both dynamic function names and\n                // dynamic parameter names. `elt` in the setter string will be captured from this\n                // context when `eval` is called.\n                const fnDef = \"function \" + functionName + \"(\" + nodeName + \") { \" + setter + \" }\";\n                try {\n                    // Define the function:\n                    eval(fnDef);\n                    // Get a reference to the function:\n                    const fn = eval(functionName);\n                    // Register the function\n                    functionsToRegister.push(fn);\n                } catch (e) {\n                    console.log(\"Could not eval:\", fnDef, \"; cause: \", e);\n                }\n            }\n        });\n        // Register DOM update functions\n        dataflow.register(...functionsToRegister);\n        \n        // DOM to dataflow:\n        // Add change listeners to input elements in DOM that will push changes into the dataflow graph.\n        // <input> elements should have class=\"dataflow-on-change\" or class=\"dataflow-on-input\", and\n        // id=\"dataflowNodeName\" (where dataflowNodeName needs to be a valid JS identifier).\n        const getInputValue = (elt) => elt.type === \"checkbox\" || elt.type === \"radio\" ? elt.checked : elt.value;\n        const initialValues = {};\n        const registerListeners = (eventName) => {\n            const attrName = \"to-dataflow-on-\" + eventName;\n            [...document.querySelectorAll(\"[\" + attrName + \"]\")].forEach(elt => {\n                if (elt.tagName.toLowerCase() !== \"input\") {\n                    throw new Error(\"Element with \" + attrName + \" attribute is not an input element: \"\n                            + elt.outerHTML);\n                }\n                const dataflowAttrVal = elt.getAttribute(attrName);\n                if (!validJSIdent.test(dataflowAttrVal)) {\n                    throw new Error(\n                        attrName + \" attribute does not specify a valid dataflow node name: \" + elt.outerHTML);\n                }\n                elt.addEventListener(eventName, () => dataflow.set({ [dataflowAttrVal]: getInputValue(elt) }));\n                initialValues[dataflowAttrVal] = getInputValue(elt);\n            })\n        };\n        registerListeners(\"change\");\n        registerListeners(\"input\");\n        // Seed dataflow graph with initial values from DOM\n        if (DEBUG_DATAFLOW) {\n            console.log(\"Initial values:\", initialValues);\n        }\n        dataflow.set(initialValues);\n    },\n};\n\n"],"names":[],"version":3,"file":"index.0f6d118b.js.map","sourceRoot":"/__parcel_source_root/"}